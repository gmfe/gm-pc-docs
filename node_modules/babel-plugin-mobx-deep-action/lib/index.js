"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function (babel) {
  var t = babel.types;

  /**
   * t.isFunctionExpression() || t.isArrowFunctionExpression()
   */

  function isAnyFunctionExpression() {
    return t.isFunctionExpression.apply(t, arguments) || t.isArrowFunctionExpression.apply(t, arguments);
  }

  function isAction(node, actionIdentifier, mobxNamespaceIdentifier) {
    return actionIdentifier && t.isIdentifier(node, { name: actionIdentifier }) || t.isMemberExpression(node) && t.isIdentifier(node.object, { name: 'action' }) && t.isIdentifier(node.property, { name: "bound" }) || mobxNamespaceIdentifier && t.isMemberExpression(node) && t.isIdentifier(node.object, { name: mobxNamespaceIdentifier }) && t.isIdentifier(node.property, { name: "action" });
  }

  var traverseActionBody = _defineProperty({}, "FunctionExpression|ArrowFunctionExpression", function FunctionExpressionArrowFunctionExpression(path) {
    var actionIdentifier = this.actionIdentifier;
    var mobxNamespaceIdentifier = this.mobxNamespaceIdentifier;
    path.traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
    path.skip();
    // if current node parent is call expression and this call is action call, skip wrapping
    if (t.isCallExpression(path.parentPath.node) && isAction(path.parentPath.node.callee, actionIdentifier, mobxNamespaceIdentifier)) {
      return;
    }
    path.replaceWith(t.CallExpression(this.actionIdentifier ? t.Identifier(this.actionIdentifier) : t.MemberExpression(t.Identifier(this.mobxNamespaceIdentifier), t.Identifier("action")), [path.node]));
  });

  var traverseSibling = _defineProperty({
    CallExpression: function CallExpression(path) {
      var node = path.node;
      var actionIdentifier = this.actionIdentifier;
      var mobxNamespaceIdentifier = this.mobxNamespaceIdentifier;
      if (isAction(node.callee, actionIdentifier, mobxNamespaceIdentifier)) {
        if (node.arguments.length === 1) {
          path.get('arguments.0').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
          path.skip();
        } else if (node.arguments.length === 2) {
          path.get('arguments.1').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
          path.skip();
        }
      }
    }
  }, "ClassMethod|ClassProperty", function ClassMethodClassProperty(path) {
    var actionIdentifier = this.actionIdentifier;
    var mobxNamespaceIdentifier = this.mobxNamespaceIdentifier;
    var explicitClasses = this.classes;
    var classDeclaration = path.findParent(function (p) {
      return p.isClassDeclaration();
    });
    // If there is an explicit classes with actions, handle them separately
    if (explicitClasses && t.isIdentifier(classDeclaration.node.id) && void 0 !== explicitClasses[classDeclaration.node.id.name] && t.isClassMethod(path.node) && t.isIdentifier(path.node.key) && (
    // all code inside constructor should be handled as action too, because it could contain other action creations
    path.node.key.name === "constructor" || void 0 !== explicitClasses[classDeclaration.node.id.name][path.node.key.name])) {
      if (path.node.key.name === "constructor") {
        path.get('body').get('body').forEach(function (cPath) {
          if (cPath.isExpressionStatement()) {
            var exprPath = cPath.get('expression');
            if (exprPath.isAssignmentExpression() && exprPath.get('operator').node === '=') {
              var leftPath = exprPath.get('left');
              var rightPath = exprPath.get('right');
              if (leftPath.isMemberExpression() && leftPath.get('object').isThisExpression() && leftPath.get('property').isIdentifier() && leftPath.get('property').node.name in explicitClasses[classDeclaration.node.id.name] && (rightPath.isArrowFunctionExpression() || rightPath.isFunctionExpression())) {
                rightPath.get('body').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
              }
            }
          }
        });
      } else {
        path.get('body').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
      }
      path.skip();
    } else if (path.node.decorators) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = path.node.decorators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref2 = _step.value;
          var expression = _ref2.expression;

          if (isAction(expression, actionIdentifier, mobxNamespaceIdentifier) || t.isCallExpression(expression) && isAction(expression.callee, actionIdentifier, mobxNamespaceIdentifier)) {
            if (t.isClassMethod(path.node)) {
              path.get('body').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
              path.skip();
            } else if (t.isClassProperty(path.node)) {
              path.get('value').traverse(traverseActionBody, { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier });
              path.skip();
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  });

  return {
    name: "mobx-deep-action-transform",
    visitor: {
      Program: function Program(path, state) {
        var actionIdentifier = void 0;
        var mobxNamespaceIdentifier = void 0;
        var tslibNamespaceIdentifier = void 0;
        var mobxPackage = state.opts && state.opts["mobx-package"] || "mobx";
        path.traverse({
          ImportDeclaration: function ImportDeclaration(path) {
            if (path.node.source.value === mobxPackage) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = path.node.specifiers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var specifier = _step2.value;

                  if (t.isImportNamespaceSpecifier(specifier) || specifier.imported.name === "action") {
                    if (t.isImportNamespaceSpecifier(specifier)) {
                      mobxNamespaceIdentifier = specifier.local.name;
                    } else if (specifier.imported.name === "action") {
                      actionIdentifier = specifier.local.name;
                    }
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
            if (path.node.source.value === "tslib") {
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = path.node.specifiers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var _specifier = _step3.value;

                  if (t.isImportNamespaceSpecifier(_specifier)) {
                    tslibNamespaceIdentifier = _specifier.local.name;
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          }
        });
        var context = { actionIdentifier: actionIdentifier, mobxNamespaceIdentifier: mobxNamespaceIdentifier };
        path.traverse(traverseSibling, context);
        var toTraverse = [];
        /**
         * Lookup for typescript decorators, and handle them separately
         */
        path.traverse({
          CallExpression: function CallExpression(path) {
            var node = path.node;
            if (t.isMemberExpression(node.callee) && t.isIdentifier(node.callee.object, { name: tslibNamespaceIdentifier }) && t.isIdentifier(node.callee.property, { name: "__decorate" }) && node.arguments.length === 4 && t.isArrayExpression(node.arguments[0]) && node.arguments[0].elements.some(function (e) {
              return t.isIdentifier(e, { name: actionIdentifier }) || t.isMemberExpression(e) && t.isIdentifier(e.object, { name: mobxNamespaceIdentifier }) && t.isIdentifier(e.property, { name: "action" }) || t.isCallExpression(e) && t.isIdentifier(e.callee, { name: actionIdentifier }) || t.isCallExpression(e) && t.isMemberExpression(e.callee) && t.isIdentifier(e.callee.object, { name: mobxNamespaceIdentifier }) && t.isIdentifier(e.callee.property, { name: "action" });
            }) && t.isMemberExpression(node.arguments[1]) && t.isIdentifier(node.arguments[1].property, { name: "prototype" }) && t.isStringLiteral(node.arguments[2])) {
              var className = node.arguments[1].object.name;
              var methodName = node.arguments[2].value;
              var traversePath = path.getStatementParent().parentPath;
              var existsTraverseRequest = toTraverse.find(function (e) {
                return e.path === traversePath;
              });
              if (!existsTraverseRequest) {
                toTraverse.push({
                  path: traversePath,
                  classes: _defineProperty({}, className, _defineProperty({}, methodName, methodName))
                });
              } else {
                var existsClassRequest = existsTraverseRequest.classes[className];
                if (!existsClassRequest) {
                  existsTraverseRequest.classes[className] = _defineProperty({}, methodName, methodName);
                } else {
                  existsTraverseRequest.classes[className][methodName] = methodName;
                }
              }
            }
          }
        });
        toTraverse.forEach(function (_ref3) {
          var path = _ref3.path,
              classes = _ref3.classes;
          return path.traverse(traverseSibling, _extends({}, context, { classes: classes }));
        });
      }
    }
  };
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }